<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="VB.J[[4+3u3eFfi;x,T%" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="gN!N`waJ*aZHHHu_#uL$" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum PingUnit {" line1="    //% block=&quot;微秒&quot;" line2="    MicroSeconds," line3="    //% block=&quot;厘米&quot;" line4="    Centimeters," line5="    //% block=&quot;英寸&quot;" line6="    Inches" line7="}" numlines="8"></mutation><next><block type="typescript_statement" id="4VzkJa(:n3.{T[eulbAA" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum TMP36Type {" line1="    //% block=&quot;(℃)&quot; enumval=0" line2="    TMP36_temperature_C," line3="" line4="    //% block=&quot;(℉)&quot; enumval=1" line5="    TMP36_temperature_F," line6="}" numlines="7"></mutation><next><block type="typescript_statement" id="D{-d@+XUC[mWA!`g;+lw" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum RGB {" line1="    //% block=&quot;红&quot;" line2="    RED," line3="    //% block=&quot;绿&quot;" line4="    GREEN," line5="    //% block=&quot;蓝&quot;" line6="    BLUE," line7="    //% block=&quot;全部&quot;" line8="    CLEAR" line9="}" numlines="10"></mutation><next><block type="typescript_statement" id="E6{nRR@#U:x5w}99cPX%" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum NeoPixelColors {" line1="    //% block=红" line2="    Red = 0xFF0000," line3="    //% block=橙" line4="    Orange = 0xFFA500," line5="    //% block=黄" line6="    Yellow = 0xFFFF00," line7="    //% block=绿" line8="    Green = 0x00FF00," line9="    //% block=蓝" line10="    Blue = 0x0000FF," line11="    //% block=靛蓝" line12="    Indigo = 0x4b0082," line13="    //% block=紫罗兰" line14="    Violet = 0x8a2be2," line15="    //% block=紫" line16="    Purple = 0xFF00FF," line17="    //% block=白" line18="    White = 0xFFFFFF," line19="    //% block=黑" line20="    Black = 0x000000" line21="}" numlines="22"></mutation><next><block type="typescript_statement" id="_K,8jvvLN98IScBlW2?W" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum NeoPixelMode {" line1="    //% block=&quot;RGB (GRB 格式)&quot;" line2="    RGB = 1," line3="    //% block=&quot;RGB+W&quot;" line4="    RGBW = 2," line5="    //% block=&quot;RGB (RGB 格式)&quot;" line6="    RGB_RGB = 3" line7="}" numlines="8"></mutation><next><block type="typescript_statement" id="unx@YzU58`ggn2)K.X9:" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace ICbit {" line1="" line2="    export enum DHT11_state {" line3="        //% block=&quot;温度(℃)&quot; enumval=0" line4="        DHT11_temperature_C," line5="" line6="        //% block=&quot;湿度(0~100)&quot; enumval=1" line7="        DHT11_humidity," line8="    }" line9="" line10="    export enum Distance_Unit_List {" line11="        //% block=&quot;厘米&quot; " line12="        Distance_Unit_cm," line13="" line14="        //% block=&quot;英寸&quot;" line15="        Distance_Unit_inch," line16="    }" line17="" line18="    export enum LED {" line19="        //% block=&quot;红&quot;" line20="        RED," line21="        //% block=&quot;绿&quot;" line22="        GREEN," line23="        //% block=&quot;蓝&quot;" line24="        BLUE," line25="        //% block=&quot;黄&quot;" line26="        YELLOW" line27="    }" line28="" line29="    //% blockId=&quot;readsoilmoisture&quot; block=&quot;土壤湿度传感器 %soilhumiditypin&quot;" line30="    //% subcategory=传感器" line31="    export function ReadSoilHumidity(soilmoisturepin: AnalogPin): number {" line32="        let voltage = 0;" line33="        let soilmoisture = 0;" line34="        voltage = pins.map(" line35="            pins.analogReadPin(soilmoisturepin)," line36="            0," line37="            1023," line38="            0," line39="            1023" line40="        );" line41="        soilmoisture = voltage;" line42="        return Math.round(soilmoisture);" line43="    }" line44="" line45="    //% blockId=&quot;readlightintensity&quot; block=&quot;光线传感器 %lightintensitypin&quot;" line46="    //% subcategory=传感器" line47="    export function ReadLightIntensity(lightintensitypin: AnalogPin): number {" line48="        let voltage2 = 0;" line49="        let lightintensity = 0;" line50="        voltage2 = pins.map(" line51="            pins.analogReadPin(lightintensitypin)," line52="            0," line53="            1023," line54="            0," line55="            1023" line56="        );" line57="        lightintensity = voltage2;" line58="        return Math.round(1023 - lightintensity);" line59="    }" line60="" line61="    //% blockId=&quot;readnoise&quot; block=&quot;声音传感器 %noisepin&quot;" line62="    //% subcategory=传感器" line63="    export function ReadNoise(noisepin: AnalogPin): number {" line64="        let level = 0" line65="        let voltage3 = 0" line66="        let noise = 0" line67="        let h = 0" line68="        let l = 0" line69="        let sumh = 0" line70="        let suml = 0" line71="        pins.digitalWritePin(DigitalPin.P0, 0)" line72="        for (let i = 0; i &lt; 1000; i++) {" line73="            level = level + pins.analogReadPin(noisepin)" line74="        }" line75="        level = level / 1000" line76="        for (let j = 0; j &lt; 1000; j++) {" line77="            voltage3 = pins.analogReadPin(noisepin)" line78="            if (voltage3 &gt;= level) {" line79="                h += 1" line80="                sumh = sumh + voltage3" line81="            } else {" line82="                l += 1" line83="                suml = suml + voltage3" line84="            }" line85="        }" line86="        if (h == 0) {" line87="            sumh = level" line88="        } else {" line89="            sumh = sumh / h" line90="        }" line91="        if (l == 0) {" line92="            suml = level" line93="        } else {" line94="            suml = suml / l" line95="        }" line96="        noise = sumh - suml" line97="        if (noise &lt;= 4) {" line98="            noise = pins.map(" line99="                noise," line100="                0," line101="                4," line102="                30," line103="                50" line104="            )" line105="        } else if (noise &lt;= 8) {" line106="            noise = pins.map(" line107="                noise," line108="                4," line109="                8," line110="                50," line111="                55" line112="            )" line113="        } else if (noise &lt;= 14) {" line114="            noise = pins.map(" line115="                noise," line116="                9," line117="                14," line118="                55," line119="                60" line120="            )" line121="        } else if (noise &lt;= 32) {" line122="            noise = pins.map(" line123="                noise," line124="                15," line125="                32," line126="                60," line127="                70" line128="            )" line129="        } else if (noise &lt;= 60) {" line130="            noise = pins.map(" line131="                noise," line132="                33," line133="                60," line134="                70," line135="                75" line136="            )" line137="        } else if (noise &lt;= 100) {" line138="            noise = pins.map(" line139="                noise," line140="                61," line141="                100," line142="                75," line143="                80" line144="            )" line145="        } else if (noise &lt;= 150) {" line146="            noise = pins.map(" line147="                noise," line148="                101," line149="                150," line150="                80," line151="                85" line152="            )" line153="        } else if (noise &lt;= 231) {" line154="            noise = pins.map(" line155="                noise," line156="                151," line157="                231," line158="                85," line159="                90" line160="            )" line161="        } else {" line162="            noise = pins.map(" line163="                noise," line164="                231," line165="                1023," line166="                90," line167="                120" line168="            )" line169="        }" line170="        noise = Math.round(noise)" line171="        return Math.round(noise)" line172="    }" line173="" line174="    /**" line175="    * toggle fans" line176="    */" line177="    //% blockId=fans block=&quot;电机风扇 %pin 切换至 $fanstate || 速度 %speed&quot;" line178="    //% fanstate.shadow=&quot;toggleOnOff&quot;" line179="    //% speed.min=0 speed.max=1023" line180="    //% expandableArgumentMode=&quot;toggle&quot;" line181="    //% subcategory=执行器" line182="    export function motorFan(pin: AnalogPin, fanstate: boolean, speed: number = 1023): void {" line183="        if (fanstate) {" line184="            pins.analogSetPeriod(pin, 1023)" line185="            pins.analogWritePin(pin, Math.map(speed, 0, 1023, 0, 1023))" line186="        }" line187="        else {" line188="            pins.analogWritePin(pin, 0)" line189="            speed = 0" line190="        }" line191="    }" line192="" line193="    /**" line194="    * get Ultrasonic distance" line195="    */" line196="    //% blockId=sonarbit" line197="    //% distance_unit.fieldEditor=&quot;gridpicker&quot;" line198="    //% distance_unit.fieldOptions.columns=2" line199="    //% subcategory=传感器" line200="    //% blockId=sonar_ping block=&quot;ping trig %trig echo %echo 单位 %unit&quot;" line201="    export function ping(trig: DigitalPin, echo: DigitalPin, unit: PingUnit, maxCmDistance = 500): number {" line202="        // send pulse" line203="        pins.setPull(trig, PinPullMode.PullNone);" line204="        pins.digitalWritePin(trig, 0);" line205="        control.waitMicros(2);" line206="        pins.digitalWritePin(trig, 1);" line207="        control.waitMicros(10);" line208="        pins.digitalWritePin(trig, 0);" line209="" line210="        // read pulse" line211="        const d = pins.pulseIn(echo, PulseValue.High, maxCmDistance * 58);" line212="" line213="        switch (unit) {" line214="            case PingUnit.Centimeters: return Math.idiv(d, 58);" line215="            case PingUnit.Inches: return Math.idiv(d, 148);" line216="            default: return d;" line217="        }" line218="    }" line219="" line220="    /**" line221="    * toggle led" line222="    */" line223="    //% blockId=LEDR block=&quot;红色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;" line224="    //% brightness.min=0 brightness.max=1023" line225="    //% ledstate.shadow=&quot;toggleOnOff&quot;" line226="    //% expandableArgumentMode=&quot;toggle&quot;" line227="    //% subcategory=执行器" line228="    export function ledRBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {" line229="        if (ledstate) {" line230="            pins.analogSetPeriod(pin, 1023)" line231="            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))" line232="        }" line233="        else {" line234="            pins.analogWritePin(pin, 1023)" line235="            brightness = 1023" line236="        }" line237="    }" line238="" line239="    /**" line240="    * toggle led" line241="    */" line242="    //% blockId=LEDG block=&quot;绿色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;" line243="    //% brightness.min=0 brightness.max=1023" line244="    //% ledstate.shadow=&quot;toggleOnOff&quot;" line245="    //% expandableArgumentMode=&quot;toggle&quot;" line246="    //% subcategory=执行器" line247="    export function ledGBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {" line248="        if (ledstate) {" line249="            pins.analogSetPeriod(pin, 1023)" line250="            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))" line251="        }" line252="        else {" line253="            pins.analogWritePin(pin, 1023)" line254="            brightness = 1023" line255="        }" line256="    }" line257="" line258="    /**" line259="    * toggle led" line260="    */" line261="    //% blockId=LEDB block=&quot;蓝色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;" line262="    //% brightness.min=0 brightness.max=1023" line263="    //% ledstate.shadow=&quot;toggleOnOff&quot;" line264="    //% expandableArgumentMode=&quot;toggle&quot;" line265="    //% subcategory=执行器" line266="    export function ledBBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {" line267="        if (ledstate) {" line268="            pins.analogSetPeriod(pin, 1023)" line269="            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))" line270="        }" line271="        else {" line272="            pins.analogWritePin(pin, 1023)" line273="            brightness = 1023" line274="        }" line275="    }" line276="" line277="    /**" line278="    * toggle led" line279="    */" line280="    //% blockId=LEDY block=&quot;黄色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;" line281="    //% brightness.min=0 brightness.max=1023" line282="    //% ledstate.shadow=&quot;toggleOnOff&quot;" line283="    //% expandableArgumentMode=&quot;toggle&quot;" line284="    //% subcategory=执行器" line285="    export function ledYBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {" line286="        if (ledstate) {" line287="            pins.analogSetPeriod(pin, 1023)" line288="            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))" line289="        }" line290="        else {" line291="            pins.analogWritePin(pin, 1023)" line292="            brightness = 1023" line293="        }" line294="    }" line295="" line296="    const PCA9685_ADD = 0x40" line297="    const MODE1 = 0x00" line298="    const LED0_ON_L = 0x06" line299="    const PRESCALE = 0xFE" line300="" line301="    let initialized = false" line302="" line303="    export enum enPos {" line304="        //% blockId=&quot;forward&quot; block=&quot;前进&quot;" line305="        forward = 1," line306="        //% blockId=&quot;stop&quot; block=&quot;后退&quot;" line307="        stop = 2" line308="    }" line309="" line310="    export enum enServo {" line311="        S1 = 0," line312="        S2," line313="        S3," line314="        S4" line315="    }" line316="" line317="    export enum enMotors {" line318="        M1 = 8," line319="        M2 = 10," line320="        M3 = 13," line321="        M4 = 15" line322="    }" line323="" line324="    function i2cwrite(addr: number, reg: number, value: number) {" line325="        let buf = pins.createBuffer(2)" line326="        buf[0] = reg" line327="        buf[1] = value" line328="        pins.i2cWriteBuffer(addr, buf)" line329="    }" line330="" line331="    function i2cread(addr: number, reg: number) {" line332="        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line333="        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line334="        return val;" line335="    }" line336="" line337="    function initPCA9685(): void {" line338="        i2cwrite(PCA9685_ADD, MODE1, 0x00)" line339="        setFreq(50);" line340="        initialized = true" line341="    }" line342="" line343="    function setFreq(freq: number): void {" line344="        // Constrain the frequency" line345="        let prescaleval = 25000000;" line346="        prescaleval /= 4096;" line347="        prescaleval /= freq;" line348="        prescaleval -= 1;" line349="        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);" line350="        let oldmode = i2cread(PCA9685_ADD, MODE1);" line351="        let newmode = (oldmode &amp; 0x7F) | 0x10; // sleep" line352="        i2cwrite(PCA9685_ADD, MODE1, newmode); // go to sleep" line353="        i2cwrite(PCA9685_ADD, PRESCALE, prescale); // set the prescaler" line354="        i2cwrite(PCA9685_ADD, MODE1, oldmode);" line355="        control.waitMicros(5000);" line356="        i2cwrite(PCA9685_ADD, MODE1, oldmode | 0xa1);" line357="    }" line358="" line359="    function setPwm(channel: number, on: number, off: number): void {" line360="        if (channel &lt; 0 || channel &gt; 15)" line361="            return;" line362="        if (!initialized) {" line363="            initPCA9685();" line364="        }" line365="        let buf2 = pins.createBuffer(5);" line366="        buf2[0] = LED0_ON_L + 4 * channel;" line367="        buf2[1] = on &amp; 0xff;" line368="        buf2[2] = (on &gt;&gt; 8) &amp; 0xff;" line369="        buf2[3] = off &amp; 0xff;" line370="        buf2[4] = (off &gt;&gt; 8) &amp; 0xff;" line371="        pins.i2cWriteBuffer(PCA9685_ADD, buf2);" line372="    }" line373="" line374="    //% blockId=SuperBit_Servo block=&quot;舵机(180°)| %num|角度 %value&quot;" line375="    //% num.min=1 num.max=4 value.min=0 value.max=180" line376="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=20" line377="    //% subcategory=执行器" line378="    export function Servo(num: enServo, value: number): void {" line379="" line380="        // 50hz: 20,000 us" line381="        let us = (value * 1800 / 180 + 600); // 0.6 ~ 2.4" line382="        let pwm = us * 4096 / 20000;" line383="        setPwm(num, 0, pwm);" line384="" line385="    }" line386="" line387="    //% blockId=SuperBit_Servo3 block=&quot;舵机(360°)| %num|姿态 %pos|角度 %value&quot;" line388="    //% num.min=1 num.max=4 value.min=0 value.max=90" line389="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=20" line390="    //% subcategory=执行器" line391="    export function Servo3(num: enServo, pos: enPos, value: number): void {" line392="" line393="        // 50hz: 20,000 us" line394="" line395="        if (pos == enPos.stop) {" line396="            let us2 = (86 * 1800 / 180 + 600); // 0.6 ~ 2.4" line397="            let pwm2 = us2 * 4096 / 20000;" line398="            setPwm(num, 0, pwm2);" line399="        }" line400="        else if (pos == enPos.forward) { //0-90 -&gt; 90 - 0" line401="            let us3 = ((90 - value) * 1800 / 180 + 600); // 0.6 ~ 2.4" line402="            let pwm3 = us3 * 4096 / 20000;" line403="            setPwm(num, 0, pwm3);" line404="        }" line405="" line406="    }" line407="" line408="    //% blockId=SuperBit_MotorRun block=&quot;电机|%index|速度(-255~255) %speed&quot;" line409="    //% speed.min=-255 speed.max=255" line410="    //% subcategory=执行器" line411="    export function MotorRun(index: enMotors, speed: number): void {" line412="        if (!initialized) {" line413="            initPCA9685()" line414="        }" line415="        speed = speed * 16; // map 255 to 4096" line416="        if (speed &gt;= 4096) {" line417="            speed = 4095" line418="        }" line419="        if (speed &lt;= -4096) {" line420="            speed = -4095" line421="        }" line422="" line423="        let a = index" line424="        let b = index + 1" line425="" line426="        if (a &gt; 10) {" line427="            if (speed &gt;= 0) {" line428="                setPwm(a, 0, speed)" line429="                setPwm(b, 0, 0)" line430="            } else {" line431="                setPwm(a, 0, 0)" line432="                setPwm(b, 0, -speed)" line433="            }" line434="        }" line435="        else {" line436="            if (speed &gt;= 0) {" line437="                setPwm(b, 0, speed)" line438="                setPwm(a, 0, 0)" line439="            } else {" line440="                setPwm(b, 0, 0)" line441="                setPwm(a, 0, -speed)" line442="            }" line443="        }" line444="    }" line445="" line446="    //% blockId=&quot;elecmagnet&quot; block=&quot;电磁铁 %pin 切换至 %magState || 磁力 %force&quot;" line447="    //% magState.shadow=&quot;toggleOnOff&quot;" line448="    //% force.min=0 force.max=1023" line449="    //% expandableArgumentMode=&quot;toggle&quot;" line450="    //% subcategory=执行器" line451="    export function elecmagnet(pin: AnalogPin, magState: boolean, force: number = 1023): void {" line452="" line453="        if (magState) {" line454="            pins.analogSetPeriod(pin, 1023)" line455="            pins.analogWritePin(pin, Math.map(force, 0, 1023, 0, 1023))" line456="        }" line457="        else {" line458="            pins.analogWritePin(pin, 0)" line459="            force = 0" line460="        }" line461="    }" line462="" line463="    //% blockId=&quot;laser_controller&quot; block=&quot;激光 %pin 切换至 %laserState || 激光 %intensity&quot;" line464="    //% laserState.shadow=&quot;toggleOnOff&quot;" line465="    //% intensity.min=0 intensity.max=1023" line466="    //% expandableArgumentMode=&quot;toggle&quot;" line467="    //% subcategory=执行器" line468="    export function laserController(pin: AnalogPin, laserState: boolean, intensity: number = 1023): void {" line469="" line470="        if (laserState) {" line471="            pins.analogSetPeriod(pin, 1023)" line472="            pins.analogWritePin(pin, Math.map(intensity, 0, 1023, 0, 1023))" line473="        }" line474="        else {" line475="            pins.analogWritePin(pin, 0)" line476="            intensity = 0" line477="        }" line478="    }" line479="" line480="    //% blockId=&quot;octopus_ReadWaterLevel&quot; block=&quot;水位传感器 %waterlevelpin&quot;" line481="    //% subcategory=传感器" line482="    export function ReadWaterLevel(waterlevelpin: AnalogPin): number {" line483="        let voltage4 = 0;" line484="        let waterLevel = 0;" line485="        voltage4 = pins.map(" line486="            pins.analogReadPin(waterlevelpin)," line487="            0," line488="            1023," line489="            0," line490="            1023" line491="        );" line492="        waterLevel = voltage4;" line493="        return Math.round(waterLevel);" line494="    }" line495="" line496="    //% blockId=&quot;ReadGasConcentration&quot; block=&quot;可燃气体传感器 %gasconcentrationpin&quot;" line497="    //% subcategory=传感器" line498="    export function ReadGasConcentration(gasconcentrationpin: AnalogPin): number {" line499="        let voltage5 = 0;" line500="        let gasConcentration = 0;" line501="        voltage5 = pins.map(" line502="            pins.analogReadPin(gasconcentrationpin)," line503="            0," line504="            1023," line505="            0," line506="            1023" line507="        );" line508="        gasConcentration = voltage5;" line509="        return Math.round(gasConcentration);" line510="    }" line511="" line512="    //% blockId=&quot;Readflame&quot; block=&quot;火焰传感器 %flamepin&quot;" line513="    //% subcategory=传感器" line514="    export function Readflame(flamepin: AnalogPin): number {" line515="        let voltage6 = 0;" line516="        let flame = 0;" line517="        voltage6 = pins.map(" line518="            pins.analogReadPin(flamepin)," line519="            0," line520="            1023," line521="            0," line522="            1023" line523="        );" line524="        flame = voltage6;" line525="        return Math.round(flame);" line526="    }" line527="" line528="    //% blockId=&quot;ReadGrayLevel&quot; block=&quot;灰度传感器 %graylevelpin&quot;" line529="    //% subcategory=传感器" line530="    export function ReadGrayLevel(graylevelpin: AnalogPin): number {" line531="        let voltage7 = 0;" line532="        let grayLevel = 0;" line533="        voltage7 = pins.map(" line534="            pins.analogReadPin(graylevelpin)," line535="            0," line536="            1023," line537="            80," line538="            1023" line539="        );" line540="        grayLevel = voltage7;" line541="        return Math.round(grayLevel);" line542="    }" line543="" line544="    //% blockId=&quot;readWaterTemp&quot; block=&quot;防水温度传感器 %waterproofpin&quot;" line545="    //% subcategory=传感器" line546="    export function readWaterTemp(waterproofpin: AnalogPin): number {" line547="        let voltage22 = 0;" line548="        let waterProofTemp = 0;" line549="        voltage22 = pins.map(" line550="            pins.analogReadPin(waterproofpin)," line551="            0," line552="            1023," line553="            0," line554="            1023" line555="        );" line556="        waterProofTemp = voltage22;" line557="        return Math.round(1023 - waterProofTemp);" line558="    }" line559="" line560="    //% blockId=potentiometerRead" line561="    //% block=&quot;电位器 %pin&quot;" line562="    //% subcategory=传感器" line563="    export function potentiometerRead(pin: AnalogPin): number {" line564="        return pins.analogReadPin(pin);" line565="    }" line566="" line567="    //% blockId=buttonState" line568="    //% block=&quot;按钮传感器 %pin&quot;" line569="    //% subcategory=传感器" line570="    export function buttonState(pin: DigitalPin): number {" line571="        return pins.digitalReadPin(pin);" line572="    }" line573="" line574="    //% blockId=closeState" line575="    //% block=&quot;近距离光电传感器 %pin&quot;" line576="    //% subcategory=传感器" line577="    export function closeState(pin: DigitalPin): number {" line578="        return pins.digitalReadPin(pin);" line579="    }" line580="" line581="    //% blockId=farState" line582="    //% block=&quot;远距离光电传感器 %pin&quot;" line583="    //% subcategory=传感器" line584="    export function farState(pin: DigitalPin): number {" line585="        return pins.digitalReadPin(pin);" line586="    }" line587="" line588="    //% blockId=hState" line589="    //% block=&quot;霍尔传感器 %pin&quot;" line590="    //% subcategory=传感器" line591="    export function hState(pin: DigitalPin): number {" line592="        return pins.digitalReadPin(pin);" line593="    }" line594="" line595="    enum LCS_Constants {" line596="        // Constants" line597="        ADDRESS = 0x29," line598="        ID = 0x12, // Register should be equal to 0x44 for the TCS34721 or TCS34725, or 0x4D for the TCS34723 or TCS34727." line599="" line600="        COMMAND_BIT = 0x80," line601="" line602="        ENABLE = 0x00," line603="        ENABLE_AIEN = 0x10, // RGBC Interrupt Enable" line604="        ENABLE_WEN = 0x08, // Wait enable - Writing 1 activates the wait timer" line605="        ENABLE_AEN = 0x02, // RGBC Enable - Writing 1 actives the ADC, 0 disables it" line606="        ENABLE_PON = 0x01, // Power on - Writing 1 activates the internal oscillator, 0 disables it" line607="        ATIME = 0x01, // Integration time" line608="        WTIME = 0x03, // Wait time (if ENABLE_WEN is asserted)" line609="        AILTL = 0x04, // Clear channel lower interrupt threshold" line610="        AILTH = 0x05," line611="        AIHTL = 0x06, // Clear channel upper interrupt threshold" line612="        AIHTH = 0x07," line613="        PERS = 0x0C, // Persistence register - basic SW filtering mechanism for interrupts" line614="        PERS_NONE = 0x00, // Every RGBC cycle generates an interrupt" line615="        PERS_1_CYCLE = 0x01, // 1 clean channel value outside threshold range generates an interrupt" line616="        PERS_2_CYCLE = 0x02, // 2 clean channel values outside threshold range generates an interrupt" line617="        PERS_3_CYCLE = 0x03, // 3 clean channel values outside threshold range generates an interrupt" line618="        PERS_5_CYCLE = 0x04, // 5 clean channel values outside threshold range generates an interrupt" line619="        PERS_10_CYCLE = 0x05, // 10 clean channel values outside threshold range generates an interrupt" line620="        PERS_15_CYCLE = 0x06, // 15 clean channel values outside threshold range generates an interrupt" line621="        PERS_20_CYCLE = 0x07, // 20 clean channel values outside threshold range generates an interrupt" line622="        PERS_25_CYCLE = 0x08, // 25 clean channel values outside threshold range generates an interrupt" line623="        PERS_30_CYCLE = 0x09, // 30 clean channel values outside threshold range generates an interrupt" line624="        PERS_35_CYCLE = 0x0A, // 35 clean channel values outside threshold range generates an interrupt" line625="        PERS_40_CYCLE = 0x0B, // 40 clean channel values outside threshold range generates an interrupt" line626="        PERS_45_CYCLE = 0x0C, // 45 clean channel values outside threshold range generates an interrupt" line627="        PERS_50_CYCLE = 0x0D, // 50 clean channel values outside threshold range generates an interrupt" line628="        PERS_55_CYCLE = 0x0E, // 55 clean channel values outside threshold range generates an interrupt" line629="        PERS_60_CYCLE = 0x0F, // 60 clean channel values outside threshold range generates an interrupt" line630="        CONFIG = 0x0D," line631="        CONFIG_WLONG = 0x02, // Choose between short and long (12x) wait times via WTIME" line632="        CONTROL = 0x0F, // Set the gain level for the sensor" line633="        STATUS = 0x13," line634="        STATUS_AINT = 0x10, // RGBC Clean channel interrupt" line635="        STATUS_AVALID = 0x01, // Indicates that the RGBC channels have completed an integration cycle" line636="" line637="        CDATAL = 0x14, // Clear channel data" line638="        CDATAH = 0x15," line639="        RDATAL = 0x16, // Red channel data" line640="        RDATAH = 0x17," line641="        GDATAL = 0x18, // Green channel data" line642="        GDATAH = 0x19," line643="        BDATAL = 0x1A, // Blue channel data" line644="        BDATAH = 0x1B," line645="" line646="        GAIN_1X = 0x00, //  1x gain" line647="        GAIN_4X = 0x01, //  4x gain" line648="        GAIN_16X = 0x02, // 16x gain" line649="        GAIN_60X = 0x03  // 60x gain" line650="    }" line651="" line652="    let LCS_integration_time_val = 0" line653="" line654="    // I2C functions" line655="" line656="    function I2C_WriteReg8(addr: number, reg: number, val: number) {" line657="        let buf3 = pins.createBuffer(2)" line658="        buf3.setNumber(NumberFormat.UInt8BE, 0, reg)" line659="        buf3.setNumber(NumberFormat.UInt8BE, 1, val)" line660="        pins.i2cWriteBuffer(addr, buf3)" line661="    }" line662="" line663="    function I2C_ReadReg8(addr: number, reg: number): number {" line664="        let buf4 = pins.createBuffer(1)" line665="        buf4.setNumber(NumberFormat.UInt8BE, 0, reg)" line666="        pins.i2cWriteBuffer(addr, buf4)" line667="        buf4 = pins.i2cReadBuffer(addr, 1)" line668="        return buf4.getNumber(NumberFormat.UInt8BE, 0);" line669="    }" line670="" line671="    function I2C_ReadReg16(addr: number, reg: number): number {" line672="        let buf5 = pins.createBuffer(1)" line673="        buf5.setNumber(NumberFormat.UInt8BE, 0, reg)" line674="        pins.i2cWriteBuffer(addr, buf5)" line675="        buf5 = pins.i2cReadBuffer(addr, 2)" line676="        // Little endian" line677="        return ((buf5.getNumber(NumberFormat.UInt8BE, 1) &lt;&lt; 8) | buf5.getNumber(NumberFormat.UInt8BE, 0));" line678="    }" line679="" line680="    //% blockId=&quot;initialize_sensor&quot; block=&quot;初始化颜色传感器&quot;" line681="    //% subcategory=&quot;传感器&quot;" line682="    export function LCS_initialize() {" line683="        // Make sure we're connected to the right sensor." line684="        let chip_id = I2C_ReadReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ID))" line685="" line686="        if (chip_id != 0x44) {" line687="            return // Incorrect chip ID" line688="        }" line689="" line690="        // Set default integration time and gain." line691="        LCS_set_integration_time(0.0048)" line692="        LCS_set_gain(LCS_Constants.GAIN_16X)" line693="" line694="        // Enable the device (by default, the device is in power down mode on bootup)." line695="        LCS_enable()" line696="    }" line697="" line698="    function LCS_enable() {" line699="        // Set the power and enable bits." line700="        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ENABLE), LCS_Constants.ENABLE_PON)" line701="        basic.pause(10) // not sure if this is right    time.sleep(0.01) // FIXME delay for 10ms" line702="" line703="        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ENABLE), (LCS_Constants.ENABLE_PON | LCS_Constants.ENABLE_AEN))" line704="    }" line705="" line706="    function LCS_set_integration_time(time: number) {" line707="        let val2 = 0x100 - (time / 0.0024) // FIXME was cast to int type" line708="        if (val2 &gt; 255) {" line709="            val2 = 255" line710="        } else if (val2 &lt; 0) {" line711="            val2 = 0" line712="        }" line713="        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ATIME), val2)" line714="        LCS_integration_time_val = val2" line715="    }" line716="" line717="    function LCS_set_gain(gain: number) {" line718="        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CONTROL), gain)" line719="    }" line720="" line721="    function LCS_set_led_state(state: boolean) {" line722="        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.PERS), LCS_Constants.PERS_NONE)" line723="        let val3 = I2C_ReadReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ENABLE))" line724="        if (state) {" line725="            val3 |= LCS_Constants.ENABLE_AIEN" line726="        } else {" line727="            val3 &amp;= ~LCS_Constants.ENABLE_AIEN" line728="        }" line729="        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ENABLE), val3)" line730="" line731="        basic.pause(2 * (256 - LCS_integration_time_val) * 2.4) // delay for long enough for there to be new (post-change) complete values available" line732="    }" line733="" line734="    //% blockId=&quot;octopus_getSensorData&quot; block=&quot;读取颜色值 %colorId&quot;" line735="    //% subcategory=&quot;传感器&quot;" line736="    export function getColorData(color: RGB): number {" line737="        basic.pause((256 - LCS_integration_time_val) * 2.4);" line738="        let sum = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CDATAL));" line739="        let vue = 0;" line740="        switch (color) {" line741="            case RGB.RED:" line742="                vue = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.RDATAL));" line743="                break;" line744="            case RGB.GREEN:" line745="                vue = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.GDATAL));" line746="                break;" line747="            case RGB.BLUE:" line748="                vue = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.BDATAL));" line749="                break;" line750="            case RGB.CLEAR:" line751="                return sum;" line752="                break;" line753="" line754="        }" line755="        vue = Math.floor(vue / sum * 255);" line756="" line757="        serial.writeLine(&quot;val: &quot; + vue);" line758="        return vue;" line759="    }" line760="" line761="" line762="    function LCS_get_raw_data(delay: boolean = false): number[] {" line763="        if (delay) {" line764="            // Delay for the integration time to allow reading immediately after the previous read." line765="            basic.pause((256 - LCS_integration_time_val) * 2.4)" line766="        }" line767="" line768="        let div = (256 - LCS_integration_time_val) * 1024" line769="        let rgbc = [0, 0, 0, 0]" line770="        rgbc[0] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.RDATAL)) / div" line771="        rgbc[1] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.GDATAL)) / div" line772="        rgbc[2] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.BDATAL)) / div" line773="        rgbc[3] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CDATAL)) / div" line774="        if (rgbc[0] &gt; 1) {" line775="            rgbc[0] = 1" line776="        }" line777="        if (rgbc[1] &gt; 1) {" line778="            rgbc[1] = 1" line779="        }" line780="        if (rgbc[2] &gt; 1) {" line781="            rgbc[2] = 1" line782="        }" line783="        if (rgbc[3] &gt; 1) {" line784="            rgbc[3] = 1" line785="        }" line786="        return rgbc" line787="    }" line788="" line789="    let font: number[] = [];" line790="    font[0] = 0x0022d422;" line791="    font[1] = 0x0022d422;" line792="    font[2] = 0x0022d422;" line793="    font[3] = 0x0022d422;" line794="    font[4] = 0x0022d422;" line795="    font[5] = 0x0022d422;" line796="    font[6] = 0x0022d422;" line797="    font[7] = 0x0022d422;" line798="    font[8] = 0x0022d422;" line799="    font[9] = 0x0022d422;" line800="    font[10] = 0x0022d422;" line801="    font[11] = 0x0022d422;" line802="    font[12] = 0x0022d422;" line803="    font[13] = 0x0022d422;" line804="    font[14] = 0x0022d422;" line805="    font[15] = 0x0022d422;" line806="    font[16] = 0x0022d422;" line807="    font[17] = 0x0022d422;" line808="    font[18] = 0x0022d422;" line809="    font[19] = 0x0022d422;" line810="    font[20] = 0x0022d422;" line811="    font[21] = 0x0022d422;" line812="    font[22] = 0x0022d422;" line813="    font[23] = 0x0022d422;" line814="    font[24] = 0x0022d422;" line815="    font[25] = 0x0022d422;" line816="    font[26] = 0x0022d422;" line817="    font[27] = 0x0022d422;" line818="    font[28] = 0x0022d422;" line819="    font[29] = 0x0022d422;" line820="    font[30] = 0x0022d422;" line821="    font[31] = 0x0022d422;" line822="    font[32] = 0x00000000;" line823="    font[33] = 0x000002e0;" line824="    font[34] = 0x00018060;" line825="    font[35] = 0x00afabea;" line826="    font[36] = 0x00aed6ea;" line827="    font[37] = 0x01991133;" line828="    font[38] = 0x010556aa;" line829="    font[39] = 0x00000060;" line830="    font[40] = 0x000045c0;" line831="    font[41] = 0x00003a20;" line832="    font[42] = 0x00051140;" line833="    font[43] = 0x00023880;" line834="    font[44] = 0x00002200;" line835="    font[45] = 0x00021080;" line836="    font[46] = 0x00000100;" line837="    font[47] = 0x00111110;" line838="    font[48] = 0x0007462e;" line839="    font[49] = 0x00087e40;" line840="    font[50] = 0x000956b9;" line841="    font[51] = 0x0005d629;" line842="    font[52] = 0x008fa54c;" line843="    font[53] = 0x009ad6b7;" line844="    font[54] = 0x008ada88;" line845="    font[55] = 0x00119531;" line846="    font[56] = 0x00aad6aa;" line847="    font[57] = 0x0022b6a2;" line848="    font[58] = 0x00000140;" line849="    font[59] = 0x00002a00;" line850="    font[60] = 0x0008a880;" line851="    font[61] = 0x00052940;" line852="    font[62] = 0x00022a20;" line853="    font[63] = 0x0022d422;" line854="    font[64] = 0x00e4d62e;" line855="    font[65] = 0x000f14be;" line856="    font[66] = 0x000556bf;" line857="    font[67] = 0x0008c62e;" line858="    font[68] = 0x0007463f;" line859="    font[69] = 0x0008d6bf;" line860="    font[70] = 0x000094bf;" line861="    font[71] = 0x00cac62e;" line862="    font[72] = 0x000f909f;" line863="    font[73] = 0x000047f1;" line864="    font[74] = 0x0017c629;" line865="    font[75] = 0x0008a89f;" line866="    font[76] = 0x0008421f;" line867="    font[77] = 0x01f1105f;" line868="    font[78] = 0x01f4105f;" line869="    font[79] = 0x0007462e;" line870="    font[80] = 0x000114bf;" line871="    font[81] = 0x000b6526;" line872="    font[82] = 0x010514bf;" line873="    font[83] = 0x0004d6b2;" line874="    font[84] = 0x0010fc21;" line875="    font[85] = 0x0007c20f;" line876="    font[86] = 0x00744107;" line877="    font[87] = 0x01f4111f;" line878="    font[88] = 0x000d909b;" line879="    font[89] = 0x00117041;" line880="    font[90] = 0x0008ceb9;" line881="    font[91] = 0x0008c7e0;" line882="    font[92] = 0x01041041;" line883="    font[93] = 0x000fc620;" line884="    font[94] = 0x00010440;" line885="    font[95] = 0x01084210;" line886="    font[96] = 0x00000820;" line887="    font[97] = 0x010f4a4c;" line888="    font[98] = 0x0004529f;" line889="    font[99] = 0x00094a4c;" line890="    font[100] = 0x000fd288;" line891="    font[101] = 0x000956ae;" line892="    font[102] = 0x000097c4;" line893="    font[103] = 0x0007d6a2;" line894="    font[104] = 0x000c109f;" line895="    font[105] = 0x000003a0;" line896="    font[106] = 0x0006c200;" line897="    font[107] = 0x0008289f;" line898="    font[108] = 0x000841e0;" line899="    font[109] = 0x01e1105e;" line900="    font[110] = 0x000e085e;" line901="    font[111] = 0x00064a4c;" line902="    font[112] = 0x0002295e;" line903="    font[113] = 0x000f2944;" line904="    font[114] = 0x0001085c;" line905="    font[115] = 0x00012a90;" line906="    font[116] = 0x010a51e0;" line907="    font[117] = 0x010f420e;" line908="    font[118] = 0x00644106;" line909="    font[119] = 0x01e8221e;" line910="    font[120] = 0x00093192;" line911="    font[121] = 0x00222292;" line912="    font[122] = 0x00095b52;" line913="    font[123] = 0x0008fc80;" line914="    font[124] = 0x000003e0;" line915="    font[125] = 0x000013f1;" line916="    font[126] = 0x00841080;" line917="    font[127] = 0x0022d422;" line918="" line919="    let _I2CAddr = 0;" line920="    let _screen = pins.createBuffer(1025);" line921="    let _buf2 = pins.createBuffer(2);" line922="    let _buf3 = pins.createBuffer(3);" line923="    let _buf4 = pins.createBuffer(4);" line924="    let _ZOOM = 1;" line925="" line926="    function cmd1(d: number) {" line927="        let n = d % 256;" line928="        pins.i2cWriteNumber(_I2CAddr, n, NumberFormat.UInt16BE);" line929="    }" line930="" line931="    function cmd2(d1: number, d2: number) {" line932="        _buf3[0] = 0;" line933="        _buf3[1] = d1;" line934="        _buf3[2] = d2;" line935="        pins.i2cWriteBuffer(_I2CAddr, _buf3);" line936="    }" line937="" line938="    function cmd3(d1: number, d2: number, d3: number) {" line939="        _buf4[0] = 0;" line940="        _buf4[1] = d1;" line941="        _buf4[2] = d2;" line942="        _buf4[3] = d3;" line943="        pins.i2cWriteBuffer(_I2CAddr, _buf4);" line944="    }" line945="" line946="    function set_pos(col: number = 0, page: number = 0) {" line947="        cmd1(0xb0 | page) // page number" line948="        let c = col * (_ZOOM + 1)" line949="        cmd1(0x00 | (c % 16)) // lower start column address" line950="        cmd1(0x10 | (c &gt;&gt; 4)) // upper start column address    " line951="    }" line952="" line953="    // clear bit" line954="    function clrbit(d: number, b: number): number {" line955="        if (d &amp; (1 &lt;&lt; b))" line956="            d -= (1 &lt;&lt; b)" line957="        return d" line958="    }" line959="" line960="    /**" line961="     * set pixel in OLED" line962="     * @param x is X alis, eg: 0" line963="     * @param y is Y alis, eg: 0" line964="     * @param color is dot color, eg: 1" line965="     */" line966="    //% blockId=&quot;OLED12864_I2C_PIXEL&quot; block=&quot;设置 pixel 在 x %x|y %y|颜色 %color&quot;" line967="    //% parts=OLED12864_I2C trackArgs=0" line968="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line969="    //% weight=80 blockGap=10 color=#0855AA" line970="    export function pixel(x: number, y: number, color: number = 1) {" line971="        let page = y &gt;&gt; 3" line972="        let shift_page = y % 8" line973="        let ind = x * (_ZOOM + 1) + page * 128 + 1" line974="        let e = (color) ? (_screen[ind] | (1 &lt;&lt; shift_page)) : clrbit(_screen[ind], shift_page)" line975="        _screen[ind] = e" line976="        set_pos(x, page)" line977="        if (_ZOOM) {" line978="            _screen[ind + 1] = e" line979="            _buf3[0] = 0x40" line980="            _buf3[1] = _buf3[2] = e" line981="            pins.i2cWriteBuffer(_I2CAddr, _buf3)" line982="        }" line983="        else {" line984="            _buf2[0] = 0x40" line985="            _buf2[1] = e" line986="            pins.i2cWriteBuffer(_I2CAddr, _buf2)" line987="        }" line988="    }" line989="" line990="    /**" line991="     * show text in OLED" line992="     * @param x is X alis, eg: 0" line993="     * @param y is Y alis, eg: 0" line994="     * @param s is the text will be show, eg: 'Hello!'" line995="     * @param color is string color, eg: 1" line996="     */" line997="    //% blockId=&quot;OLED12864_I2C_SHOWSTRING&quot; block=&quot;显示 string 在 x %x|y %y|文本 %s|颜色 %color&quot;" line998="    //% parts=OLED12864_I2C trackArgs=0" line999="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line1000="    //% weight=80 blockGap=10 color=#0855AA" line1001="    export function showString(x: number, y: number, s: string, color: number = 1) {" line1002="        let col = 0" line1003="        let p = 0" line1004="        let ind2 = 0" line1005="        for (let o = 0; o &lt; s.length; o++) {" line1006="            p = font[s.charCodeAt(o)]" line1007="            for (let k = 0; k &lt; 5; k++) {" line1008="                col = 0" line1009="                for (let m = 0; m &lt; 5; m++) {" line1010="                    if (p &amp; (1 &lt;&lt; (5 * k + m)))" line1011="                        col |= (1 &lt;&lt; (m + 1))" line1012="                }" line1013="                ind2 = (x + o) * 5 * (_ZOOM + 1) + y * 128 + k * (_ZOOM + 1) + 1" line1014="                if (color == 0)" line1015="                    col = 255 - col" line1016="                _screen[ind2] = col" line1017="                if (_ZOOM)" line1018="                    _screen[ind2 + 1] = col" line1019="            }" line1020="        }" line1021="        set_pos(x * 5, y)" line1022="        let ind0 = x * 5 * (_ZOOM + 1) + y * 128" line1023="        let buf6 = _screen.slice(ind0, ind2 + 1)" line1024="        buf6[0] = 0x40" line1025="        pins.i2cWriteBuffer(_I2CAddr, buf6)" line1026="    }" line1027="" line1028="    /**" line1029="     * show a number in OLED" line1030="     * @param x is X alis, eg: 0" line1031="     * @param y is Y alis, eg: 0" line1032="     * @param num is the number will be show, eg: 12" line1033="     * @param color is number color, eg: 1" line1034="     */" line1035="    //% blockId=&quot;OLED12864_I2C_NUMBER&quot; block=&quot;显示 数字 在 x %x|y %y|数字 %num|颜色 %color&quot;" line1036="    //% parts=OLED12864_I2C trackArgs=0" line1037="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line1038="    //% weight=80 blockGap=10 color=#0855AA" line1039="    export function showNumber(x: number, y: number, num: number, color: number = 1) {" line1040="        showString(x, y, num.toString(), color)" line1041="    }" line1042="" line1043="    /**" line1044="     * draw / redraw screen" line1045="     */" line1046="    //% blockId=&quot;OLED12864_I2C_DRAW&quot; block=&quot;画&quot;" line1047="    //% parts=OLED12864_I2C trackArgs=0" line1048="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line1049="    //% weight=64 blockGap=10 color=#0855AA" line1050="    export function draw() {" line1051="        set_pos()" line1052="        pins.i2cWriteBuffer(_I2CAddr, _screen)" line1053="    }" line1054="" line1055="    /**" line1056="     * clear screen" line1057="     */" line1058="    //% blockId=&quot;OLED12864_I2C_CLEAR&quot; block=&quot;清除&quot;" line1059="    //% parts=OLED12864_I2C trackArgs=0" line1060="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line1061="    //% weight=63 blockGap=10 color=#0855AA" line1062="    export function clear() {" line1063="        _screen.fill(0)" line1064="        _screen[0] = 0x40" line1065="        draw()" line1066="    }" line1067="" line1068="    /**" line1069="     * OLED initialize" line1070="     * @param addr is i2c addr, eg: 60" line1071="     */" line1072="    //% blockId=&quot;OLED12864_I2C_init&quot; block=&quot;初始化 OLED 地址为 %addr&quot;" line1073="    //% parts=OLED12864_I2C trackArgs=0" line1074="    //% weight=85 blockGap=10" line1075="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line1076="    //% blockGap=10  color=#0855AA" line1077="    export function init(addr: number) {" line1078="        _I2CAddr = addr;" line1079="        cmd1(0xAE)       // SSD1306_DISPLAYOFF" line1080="        cmd1(0xA4)       // SSD1306_DISPLAYALLON_RESUME" line1081="        cmd2(0xD5, 0xF0) // SSD1306_SETDISPLAYCLOCKDIV" line1082="        cmd2(0xA8, 0x3F) // SSD1306_SETMULTIPLEX" line1083="        cmd2(0xD3, 0x00) // SSD1306_SETDISPLAYOFFSET" line1084="        cmd1(0 | 0x0)    // line #SSD1306_SETSTARTLINE" line1085="        cmd2(0x8D, 0x14) // SSD1306_CHARGEPUMP" line1086="        cmd2(0x20, 0x00) // SSD1306_MEMORYMODE" line1087="        cmd3(0x21, 0, 127) // SSD1306_COLUMNADDR" line1088="        cmd3(0x22, 0, 63)  // SSD1306_PAGEADDR" line1089="        cmd1(0xa0 | 0x1) // SSD1306_SEGREMAP" line1090="        cmd1(0xc8)       // SSD1306_COMSCANDEC" line1091="        cmd2(0xDA, 0x12) // SSD1306_SETCOMPINS" line1092="        cmd2(0x81, 0xCF) // SSD1306_SETCONTRAST" line1093="        cmd2(0xd9, 0xF1) // SSD1306_SETPRECHARGE" line1094="        cmd2(0xDB, 0x40) // SSD1306_SETVCOMDETECT" line1095="        cmd1(0xA6)       // SSD1306_NORMALDISPLAY" line1096="        cmd2(0xD6, 1)    // zoom on" line1097="        cmd1(0xAF)       // SSD1306_DISPLAYON" line1098="        clear()" line1099="        _ZOOM = 1" line1100="    }" line1101="" line1102="    /**" line1103="     * A NeoPixel strip" line1104="     */" line1105="    export class Strip {" line1106="        buf: Buffer;" line1107="        pin: DigitalPin;" line1108="        // TODO: encode as bytes instead of 32bit" line1109="        brightness: number;" line1110="        start: number; // start offset in LED strip" line1111="        _length: number; // number of LEDs" line1112="        _mode: NeoPixelMode;" line1113="        _matrixWidth: number; // number of leds in a matrix - if any" line1114="" line1115="        /**" line1116="         * Shows all LEDs to a given color (range 0-255 for r, g, b)." line1117="         * @param rgb RGB color of the LED" line1118="         */" line1119="        //% blockId=&quot;neopixel_set_strip_color&quot; block=&quot;%strip|显示 颜色 %rgb=neopixel_colors&quot;" line1120="        //% strip.defl=strip" line1121="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1122="        //% color=#2699BF blockGap=10" line1123="        showColor(rgb: number) {" line1124="            rgb = rgb &gt;&gt; 0;" line1125="            this.setAllRGB(rgb);" line1126="            this.show();" line1127="        }" line1128="" line1129="        /**" line1130="         * Shows a rainbow pattern on all LEDs." line1131="         * @param startHue the start hue value for the rainbow, eg: 1" line1132="         * @param endHue the end hue value for the rainbow, eg: 360" line1133="         */" line1134="        //% blockId=&quot;neopixel_set_strip_rainbow&quot; block=&quot;%strip|显示 彩虹 从 %startHue|到 %endHue&quot;" line1135="        //% strip.defl=strip" line1136="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot; " line1137="        //% color=#2699BF blockGap=10" line1138="        showRainbow(startHue: number = 1, endHue: number = 360) {" line1139="            if (this._length &lt;= 0) return;" line1140="" line1141="            startHue = startHue &gt;&gt; 0;" line1142="            endHue = endHue &gt;&gt; 0;" line1143="            const saturation = 100;" line1144="            const luminance = 50;" line1145="            const steps = this._length;" line1146="            const direction = HueInterpolationDirection.Clockwise;" line1147="" line1148="            //hue" line1149="            const h1 = startHue;" line1150="            const h2 = endHue;" line1151="            const hDistCW = ((h2 + 360) - h1) % 360;" line1152="            const hStepCW = Math.idiv((hDistCW * 100), steps);" line1153="            const hDistCCW = ((h1 + 360) - h2) % 360;" line1154="            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line1155="            let hStep: number;" line1156="            if (direction === HueInterpolationDirection.Clockwise) {" line1157="                hStep = hStepCW;" line1158="            } else if (direction === HueInterpolationDirection.CounterClockwise) {" line1159="                hStep = hStepCCW;" line1160="            } else {" line1161="                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line1162="            }" line1163="            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line1164="" line1165="            //sat" line1166="            const s1 = saturation;" line1167="            const s2 = saturation;" line1168="            const sDist = s2 - s1;" line1169="            const sStep = Math.idiv(sDist, steps);" line1170="            const s1_100 = s1 * 100;" line1171="" line1172="            //lum" line1173="            const l1 = luminance;" line1174="            const l2 = luminance;" line1175="            const lDist = l2 - l1;" line1176="            const lStep = Math.idiv(lDist, steps);" line1177="            const l1_100 = l1 * 100" line1178="" line1179="            //interpolate" line1180="            if (steps === 1) {" line1181="                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line1182="            } else {" line1183="                this.setPixelColor(0, hsl(startHue, saturation, luminance));" line1184="                for (let q = 1; q &lt; steps - 1; q++) {" line1185="                    const r = Math.idiv((h1_100 + q * hStep), 100) + 360;" line1186="                    const s = Math.idiv((s1_100 + q * sStep), 100);" line1187="                    const t = Math.idiv((l1_100 + q * lStep), 100);" line1188="                    this.setPixelColor(q, hsl(r, s, t));" line1189="                }" line1190="                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));" line1191="            }" line1192="            this.show();" line1193="        }" line1194="" line1195="        /**" line1196="         * Displays a vertical bar graph based on the `value` and `high` value." line1197="         * If `high` is 0, the chart gets adjusted automatically." line1198="         * @param value current value to plot" line1199="         * @param high maximum value, eg: 255" line1200="         */" line1201="        //% blockId=neopixel_show_bar_graph block=&quot;%strip|显示 柱状图 从 %value|到 %high&quot;" line1202="        //% icon=&quot;\uf080&quot;" line1203="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1204="        //% color=#2699BF blockGap=10" line1205="        showBarGraph(value: number, high: number): void {" line1206="            if (high &lt;= 0) {" line1207="                this.clear();" line1208="                this.setPixelColor(0, NeoPixelColors.Yellow);" line1209="                this.show();" line1210="                return;" line1211="            }" line1212="" line1213="            value = Math.abs(value);" line1214="            const u = this._length;" line1215="            const n1 = u - 1;" line1216="            let v = Math.idiv((value * u), high);" line1217="            if (v == 0) {" line1218="                this.setPixelColor(0, 0x666600);" line1219="                for (let w = 1; w &lt; u; ++w)" line1220="                    this.setPixelColor(w, 0);" line1221="            } else {" line1222="                for (let f = 0; f &lt; u; ++f) {" line1223="                    if (f &lt;= v) {" line1224="                        const g = Math.idiv(f * 255, n1);" line1225="                        this.setPixelColor(f, ICbit.rgb(g, 0, 255 - g));" line1226="                    }" line1227="                    else this.setPixelColor(f, 0);" line1228="                }" line1229="            }" line1230="            this.show();" line1231="        }" line1232="" line1233="        /**" line1234="         * Set LED to a given color (range 0-255 for r, g, b)." line1235="         * You need to call ``show`` to make the changes visible." line1236="         * @param pixeloffset position of the NeoPixel in the strip" line1237="         * @param rgb RGB color of the LED" line1238="         */" line1239="        //% blockId=&quot;neopixel_set_pixel_color&quot; block=&quot;%strip|设置 pixel 颜色 在 %pixeloffset|到 %rgb=neopixel_colors&quot;" line1240="        //% strip.defl=strip" line1241="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1242="        //% color=#2699BF blockGap=10" line1243="        setPixelColor(pixeloffset: number, rgb: number): void {" line1244="            this.setPixelRGB(pixeloffset &gt;&gt; 0, rgb &gt;&gt; 0);" line1245="        }" line1246="" line1247="        /**" line1248="         * Sets the number of pixels in a matrix shaped strip" line1249="         * @param width number of pixels in a row" line1250="         */" line1251="        //% blockId=neopixel_set_matrix_width block=&quot;%strip|设置 矩阵 宽度 %width&quot;" line1252="        //% strip.defl=strip" line1253="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot; " line1254="        //% color=#2699BF blockGap=10" line1255="        setMatrixWidth(width: number) {" line1256="            this._matrixWidth = Math.min(this._length, width &gt;&gt; 0);" line1257="        }" line1258="" line1259="        /**" line1260="         * Set LED to a given color (range 0-255 for r, g, b) in a matrix shaped strip" line1261="         * You need to call ``show`` to make the changes visible." line1262="         * @param x horizontal position" line1263="         * @param y horizontal position" line1264="         * @param rgb RGB color of the LED" line1265="         */" line1266="        //% blockId=&quot;neopixel_set_matrix_color&quot; block=&quot;%strip|设置 矩阵 颜色 在 x %x|y %y|到 %rgb=neopixel_colors&quot;" line1267="        //% strip.defl=strip" line1268="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1269="        //% color=#2699BF blockGap=10" line1270="        setMatrixColor(x: number, y: number, rgb: number) {" line1271="            if (this._matrixWidth &lt;= 0) return; // not a matrix, ignore" line1272="            x = x &gt;&gt; 0;" line1273="            y = y &gt;&gt; 0;" line1274="            rgb = rgb &gt;&gt; 0;" line1275="            const cols = Math.idiv(this._length, this._matrixWidth);" line1276="            if (x &lt; 0 || x &gt;= this._matrixWidth || y &lt; 0 || y &gt;= cols) return;" line1277="            let i2 = x + y * this._matrixWidth;" line1278="            this.setPixelColor(i2, rgb);" line1279="        }" line1280="" line1281="        /**" line1282="         * For NeoPixels with RGB+W LEDs, set the white LED brightness. This only works for RGB+W NeoPixels." line1283="         * @param pixeloffset position of the LED in the strip" line1284="         * @param white brightness of the white LED" line1285="         */" line1286="        //% blockId=&quot;neopixel_set_pixel_white&quot; block=&quot;%strip|设置 pixel 白色 LED 在 %pixeloffset|到 %white&quot;" line1287="        //% strip.defl=strip" line1288="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1289="        //% color=#2699BF blockGap=10" line1290="        setPixelWhiteLED(pixeloffset: number, white: number): void {" line1291="            if (this._mode === NeoPixelMode.RGBW) {" line1292="                this.setPixelW(pixeloffset &gt;&gt; 0, white &gt;&gt; 0);" line1293="            }" line1294="        }" line1295="" line1296="        /**" line1297="         * Send all the changes to the strip." line1298="         */" line1299="        //% blockId=&quot;neopixel_show&quot; block=&quot;%strip|显示&quot;" line1300="        //% strip.defl=strip" line1301="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1302="        //% color=#2699BF blockGap=10" line1303="        show() {" line1304="            // only supported in beta" line1305="            // ws2812b.setBufferMode(this.pin, this._mode);" line1306="            ws2812b.sendBuffer(this.buf, this.pin);" line1307="        }" line1308="" line1309="        /**" line1310="         * Turn off all LEDs." line1311="         * You need to call ``show`` to make the changes visible." line1312="         */" line1313="        //% blockId=&quot;neopixel_clear&quot; block=&quot;%strip|清除&quot;" line1314="        //% strip.defl=strip" line1315="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1316="        //% color=#2699BF blockGap=10" line1317="        clear(): void {" line1318="            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1319="            this.buf.fill(0, this.start * stride, this._length * stride);" line1320="        }" line1321="" line1322="        /**" line1323="         * Gets the number of pixels declared on the strip" line1324="         */" line1325="        //% blockId=&quot;neopixel_length&quot; block=&quot;%strip|长度&quot;" line1326="        //% strip.defl=strip" line1327="        //% weight=32" line1328="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1329="        //% color=#2699BF blockGap=10" line1330="        length() {" line1331="            return this._length;" line1332="        }" line1333="" line1334="        /**" line1335="         * Set the brightness of the strip. This flag only applies to future operation." line1336="         * @param brightness a measure of LED brightness in 0-255. eg: 255" line1337="         */" line1338="        //% blockId=&quot;neopixel_set_brightness&quot; block=&quot;%strip|设置 亮度 %brightness&quot;" line1339="        //% strip.defl=strip" line1340="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1341="        //% color=#2699BF blockGap=10" line1342="        setBrightness(brightness: number): void {" line1343="            this.brightness = brightness &amp; 0xff;" line1344="        }" line1345="" line1346="        /**" line1347="         * Apply brightness to current colors using a quadratic easing function." line1348="         **/" line1349="        //% blockId=&quot;neopixel_each_brightness&quot; block=&quot;%strip|清除 亮度&quot;" line1350="        //% strip.defl=strip" line1351="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1352="        //% color=#2699BF blockGap=10" line1353="        easeBrightness(): void {" line1354="            const stride2 = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1355="            const br = this.brightness;" line1356="            const buf7 = this.buf;" line1357="            const end = this.start + this._length;" line1358="            const mid = Math.idiv(this._length, 2);" line1359="            for (let i3 = this.start; i3 &lt; end; ++i3) {" line1360="                const k2 = i3 - this.start;" line1361="                const ledoffset = i3 * stride2;" line1362="                const br2 = k2 &gt; mid" line1363="                    ? Math.idiv(255 * (this._length - 1 - k2) * (this._length - 1 - k2), (mid * mid))" line1364="                    : Math.idiv(255 * k2 * k2, (mid * mid));" line1365="                const r2 = (buf7[ledoffset + 0] * br2) &gt;&gt; 8; buf7[ledoffset + 0] = r2;" line1366="                const g2 = (buf7[ledoffset + 1] * br2) &gt;&gt; 8; buf7[ledoffset + 1] = g2;" line1367="                const b2 = (buf7[ledoffset + 2] * br2) &gt;&gt; 8; buf7[ledoffset + 2] = b2;" line1368="                if (stride2 == 4) {" line1369="                    const w2 = (buf7[ledoffset + 3] * br2) &gt;&gt; 8; buf7[ledoffset + 3] = w2;" line1370="                }" line1371="            }" line1372="        }" line1373="" line1374="        /**" line1375="         * Create a range of LEDs." line1376="         * @param start offset in the LED strip to start the range" line1377="         * @param length number of LEDs in the range. eg: 4" line1378="         */" line1379="        //% blockId=&quot;neopixel_range&quot; block=&quot;%strip|值域 从 %start|到 %length|leds&quot;" line1380="        //% strip.defl=strip" line1381="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1382="        //% blockSetVariable=range" line1383="        //% weight= 52" line1384="        //% color=#2699BF blockGap=10" line1385="        range(start: number, length: number): Strip {" line1386="            start = start &gt;&gt; 0;" line1387="            length = length &gt;&gt; 0;" line1388="            let strip = new Strip();" line1389="            strip.buf = this.buf;" line1390="            strip.pin = this.pin;" line1391="            strip.brightness = this.brightness;" line1392="            strip.start = this.start + Math.clamp(0, this._length - 1, start);" line1393="            strip._length = Math.clamp(0, this._length - (strip.start - this.start), length);" line1394="            strip._matrixWidth = 0;" line1395="            strip._mode = this._mode;" line1396="            return strip;" line1397="        }" line1398="" line1399="        /**" line1400="         * Shift LEDs forward and clear with zeros." line1401="         * You need to call ``show`` to make the changes visible." line1402="         * @param offset number of pixels to shift forward, eg: 1" line1403="         */" line1404="        //% blockId=&quot;neopixel_shift&quot; block=&quot;%strip|移动 pixels %offset&quot;" line1405="        //% strip.defl=strip" line1406="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1407="        //% color=#2699BF blockGap=10" line1408="        //% weight= 50" line1409="        shift(offset: number = 1): void {" line1410="            offset = offset &gt;&gt; 0;" line1411="            const stride3 = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1412="            this.buf.shift(-offset * stride3, this.start * stride3, this._length * stride3)" line1413="        }" line1414="" line1415="        /**" line1416="         * Rotate LEDs forward." line1417="         * You need to call ``show`` to make the changes visible." line1418="         * @param offset number of pixels to rotate forward, eg: 1" line1419="         */" line1420="        //% blockId=&quot;neopixel_rotate&quot; block=&quot;%strip|旋转 pixels %offset&quot;" line1421="        //% strip.defl=strip" line1422="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1423="        //% color=#2699BF blockGap=10" line1424="        //% weight= 50" line1425="        rotate(offset: number = 1): void {" line1426="            offset = offset &gt;&gt; 0;" line1427="            const stride4 = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1428="            this.buf.rotate(-offset * stride4, this.start * stride4, this._length * stride4)" line1429="        }" line1430="" line1431="        /**" line1432="         * Set the pin where the neopixel is connected, defaults to P0." line1433="         */" line1434="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1435="        //% color=#2699BF blockGap=10" line1436="        setPin(pin: DigitalPin): void {" line1437="            this.pin = pin;" line1438="            pins.digitalWritePin(this.pin, 0);" line1439="            // don't yield to avoid races on initialization" line1440="        }" line1441="" line1442="        /**" line1443="         * Estimates the electrical current (mA) consumed by the current light configuration." line1444="         */" line1445="        //% blockId=neopixel_power block=&quot;%strip|电力 (mA)&quot;" line1446="        //% strip.defl=strip" line1447="        //% weight=32" line1448="        //% advanced= true" line1449="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1450="        //% color=#2699BF blockGap=10" line1451="        power(): number {" line1452="            const stride5 = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1453="            const end2 = this.start + this._length;" line1454="            let p2 = 0;" line1455="            for (let i4 = this.start; i4 &lt; end2; ++i4) {" line1456="                const ledoffset2 = i4 * stride5;" line1457="                for (let j2 = 0; j2 &lt; stride5; ++j2) {" line1458="                    p2 += this.buf[i4 + j2];" line1459="                }" line1460="            }" line1461="            return Math.idiv(this.length() * 7, 10) /* 0.7mA per neopixel */" line1462="                + Math.idiv(p2 * 480, 10000); /* rought approximation */" line1463="        }" line1464="" line1465="        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {" line1466="            if (this._mode === NeoPixelMode.RGB_RGB) {" line1467="                this.buf[offset + 0] = red;" line1468="                this.buf[offset + 1] = green;" line1469="            } else {" line1470="                this.buf[offset + 0] = green;" line1471="                this.buf[offset + 1] = red;" line1472="            }" line1473="            this.buf[offset + 2] = blue;" line1474="        }" line1475="" line1476="        private setAllRGB(rgb: number) {" line1477="            let red = unpackR(rgb);" line1478="            let green = unpackG(rgb);" line1479="            let blue = unpackB(rgb);" line1480="" line1481="            const br3 = this.brightness;" line1482="            if (br3 &lt; 255) {" line1483="                red = (red * br3) &gt;&gt; 8;" line1484="                green = (green * br3) &gt;&gt; 8;" line1485="                blue = (blue * br3) &gt;&gt; 8;" line1486="            }" line1487="            const end3 = this.start + this._length;" line1488="            const stride6 = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1489="            for (let i5 = this.start; i5 &lt; end3; ++i5) {" line1490="                this.setBufferRGB(i5 * stride6, red, green, blue)" line1491="            }" line1492="        }" line1493="        private setAllW(white: number) {" line1494="            if (this._mode !== NeoPixelMode.RGBW)" line1495="                return;" line1496="" line1497="            let br4 = this.brightness;" line1498="            if (br4 &lt; 255) {" line1499="                white = (white * br4) &gt;&gt; 8;" line1500="            }" line1501="            let buf8 = this.buf;" line1502="            let end4 = this.start + this._length;" line1503="            for (let i6 = this.start; i6 &lt; end4; ++i6) {" line1504="                let ledoffset3 = i6 * 4;" line1505="                buf8[ledoffset3 + 3] = white;" line1506="            }" line1507="        }" line1508="        private setPixelRGB(pixeloffset: number, rgb: number): void {" line1509="            if (pixeloffset &lt; 0" line1510="                || pixeloffset &gt;= this._length)" line1511="                return;" line1512="" line1513="            let stride7 = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1514="            pixeloffset = (pixeloffset + this.start) * stride7;" line1515="" line1516="            let red2 = unpackR(rgb);" line1517="            let green2 = unpackG(rgb);" line1518="            let blue2 = unpackB(rgb);" line1519="" line1520="            let br5 = this.brightness;" line1521="            if (br5 &lt; 255) {" line1522="                red2 = (red2 * br5) &gt;&gt; 8;" line1523="                green2 = (green2 * br5) &gt;&gt; 8;" line1524="                blue2 = (blue2 * br5) &gt;&gt; 8;" line1525="            }" line1526="            this.setBufferRGB(pixeloffset, red2, green2, blue2)" line1527="        }" line1528="        private setPixelW(pixeloffset: number, white: number): void {" line1529="            if (this._mode !== NeoPixelMode.RGBW)" line1530="                return;" line1531="" line1532="            if (pixeloffset &lt; 0" line1533="                || pixeloffset &gt;= this._length)" line1534="                return;" line1535="" line1536="            pixeloffset = (pixeloffset + this.start) * 4;" line1537="" line1538="            let br6 = this.brightness;" line1539="            if (br6 &lt; 255) {" line1540="                white = (white * br6) &gt;&gt; 8;" line1541="            }" line1542="            let buf9 = this.buf;" line1543="            buf9[pixeloffset + 3] = white;" line1544="        }" line1545="    }" line1546="" line1547="    /**" line1548="     * Create a new NeoPixel driver for `numleds` LEDs." line1549="     * @param pin the pin where the neopixel is connected." line1550="     * @param numleds number of leds in the strip, eg: 24,30,60,64" line1551="     */" line1552="    //% blockId=&quot;neopixel_create&quot; block=&quot;NeoPixel 在 端口 %pin|用 %numleds| leds 模式 %mode&quot;" line1553="    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1554="    //% trackArgs=0,2" line1555="    //% blockSetVariable=strip" line1556="    //% color=#2699BF blockGap=10" line1557="    //% weight=51" line1558="    export function create(pin: DigitalPin, numleds: number, mode: NeoPixelMode): Strip {" line1559="        let strip2 = new Strip();" line1560="        let stride8 = mode === NeoPixelMode.RGBW ? 4 : 3;" line1561="        strip2.buf = pins.createBuffer(numleds * stride8);" line1562="        strip2.start = 0;" line1563="        strip2._length = numleds;" line1564="        strip2._mode = mode || NeoPixelMode.RGB;" line1565="        strip2._matrixWidth = 0;" line1566="        strip2.setBrightness(128)" line1567="        strip2.setPin(pin)" line1568="        return strip2;" line1569="    }" line1570="" line1571="    /**" line1572="     * Converts red, green, blue channels into a RGB color" line1573="     * @param red value of the red channel between 0 and 255. eg: 255" line1574="     * @param green value of the green channel between 0 and 255. eg: 255" line1575="     * @param blue value of the blue channel between 0 and 255. eg: 255" line1576="     */" line1577="    //% blockId=&quot;neopixel_rgb&quot; block=&quot;红 %red|绿 %green|蓝 %blue&quot;" line1578="    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1579="    //% weight=32" line1580="    //% color=#2699BF blockGap=10" line1581="    export function rgb(red: number, green: number, blue: number): number {" line1582="        return packRGB(red, green, blue);" line1583="    }" line1584="" line1585="    /**" line1586="     * Gets the RGB value of a known color" line1587="    */" line1588="    //% blockId=&quot;neopixel_colors&quot; block=&quot;%color&quot;" line1589="    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1590="    //% weight=32" line1591="    //% color=#2699BF blockGap=10" line1592="    export function colors(color: NeoPixelColors): number {" line1593="        return color;" line1594="    }" line1595="" line1596="    function packRGB(a: number, b: number, c: number): number {" line1597="        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);" line1598="    }" line1599="" line1600="    function unpackR(rgb: number): number {" line1601="        let r3 = (rgb &gt;&gt; 16) &amp; 0xFF;" line1602="        return r3;" line1603="    }" line1604="    " line1605="    function unpackG(rgb: number): number {" line1606="        let g3 = (rgb &gt;&gt; 8) &amp; 0xFF;" line1607="        return g3;" line1608="    }" line1609="" line1610="    function unpackB(rgb: number): number {" line1611="        let b3 = (rgb) &amp; 0xFF;" line1612="        return b3;" line1613="    }" line1614="" line1615="    /**" line1616="     * Converts a hue saturation luminosity value into a RGB color" line1617="     * @param h hue from 0 to 360" line1618="     * @param s saturation from 0 to 99" line1619="     * @param l luminosity from 0 to 99" line1620="     */" line1621="    //% blockId=neopixelHSL block=&quot;色度 %h|饱和度 %s|亮度 %l&quot;" line1622="    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1623="    //% weight=32" line1624="    //% color=#2699BF blockGap=10" line1625="    export function hsl(h: number, s: number, l: number): number {" line1626="        h = Math.round(h);" line1627="        s = Math.round(s);" line1628="        l = Math.round(l);" line1629="" line1630="        h = h % 360;" line1631="        s = Math.clamp(0, 99, s);" line1632="        l = Math.clamp(0, 99, l);" line1633="        let c2 = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line1634="        let h12 = Math.idiv(h, 60);//[0,6]" line1635="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line1636="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line1637="        let x = (c2 * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line1638="        let r$: number;" line1639="        let g$: number;" line1640="        let b$: number;" line1641="        if (h12 == 0) {" line1642="            r$ = c2; g$ = x; b$ = 0;" line1643="        } else if (h12 == 1) {" line1644="            r$ = x; g$ = c2; b$ = 0;" line1645="        } else if (h12 == 2) {" line1646="            r$ = 0; g$ = c2; b$ = x;" line1647="        } else if (h12 == 3) {" line1648="            r$ = 0; g$ = x; b$ = c2;" line1649="        } else if (h12 == 4) {" line1650="            r$ = x; g$ = 0; b$ = c2;" line1651="        } else if (h12 == 5) {" line1652="            r$ = c2; g$ = 0; b$ = x;" line1653="        }" line1654="        let m2 = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - c2), 2);" line1655="        let r4 = r$ + m2;" line1656="        let g4 = g$ + m2;" line1657="        let b4 = b$ + m2;" line1658="        return packRGB(r4, g4, b4);" line1659="    }" line1660="" line1661="    export enum HueInterpolationDirection {" line1662="        Clockwise," line1663="        CounterClockwise," line1664="        Shortest" line1665="    }" line1666="}" numlines="1667"></mutation></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>